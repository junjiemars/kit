#!/bin/sh
#------------------------------------------------
# target: shell env setup script
# author: Junjie Mars
#------------------------------------------------

HOME="${HOME%/}"
PH="/usr/bin:/bin:/usr/sbin:/sbin"
unset -f command 2>/dev/null

# check env
# check commands
set -e
awk=$(PATH=$PH command -v awk)
basename=$(PATH=$PH command -v basename)
cat=$(PATH=$PH command -v cat)
chmod=$(PATH=$PH command -v chmod)
cp=$(PATH=$PH command -v cp)
cut=$(PATH=$PH command -v cut)
date=$(PATH=$PH command -v date)
dd=$(PATH=$PH command -v dd)
dirname=$(PATH=$PH command -v dirname)
env=$(PATH=$PH command -v env)
find=$(PATH=$PH command -v find)
grep=$(PATH=$PH command -v grep)
iconv=$(PATH=$PH command -v iconv)
locale=$(PATH=$PH command -v locale)
ls=$(PATH=$PH command -v ls)
mkdir=$(PATH=$PH command -v mkdir)
printf=$(PATH=$PH command -v printf)
ps=$(PATH=$PH command -v ps)
rm=$(PATH=$PH command -v rm)
stat=$(PATH=$PH command -v stat)
sed=$(PATH=$PH command -v sed)
sort=$(PATH=$PH command -v sort)
tail=$(PATH=$PH command -v tail)
tr=$(PATH=$PH command -v tr)
uname=$(PATH=$PH command -v uname)
uniq=$(PATH=$PH command -v uniq)
xargs=$(PATH=$PH command -v xargs)
# check shell
PLATFORM=$($uname -s 2>/dev/null)
on_windows_nt () {
 case $PLATFORM in
   MSYS_NT*|MINGW*) return 0 ;;
   *) return 1 ;;
 esac
}
on_darwin () {
  case $PLATFORM in
    Darwin) return 0 ;;
    *) return 1 ;;
  esac
}
on_linux () {
  case $PLATFORM in
    Linux) return 0 ;;
    *) return 1 ;;
  esac
}
SH_ENV="https://raw.githubusercontent.com/junjiemars/kit/master/ul/sh.sh"
SHELL=$($ps -p$$ -ocommand 2>/dev/null|$sed 1d|$cut -d ' ' -f1|$tr -d '-')
if test -z "$SHELL" && on_windows_nt; then
  SHELL=$(PATH=$PH command -v bash)
fi
SH="$($basename $SHELL)"
set +e


echo_yes_or_no () {
  local c="$1"
  if [ 0 -eq $c ]; then
    $printf "yes\n"
  else
    $printf "no\n"
  fi
  return $c
}

save_as () {
  local f="$1"
  local ori="${f}.ori"
  local pre="${f}.pre"

  if [ -n "$f" ] && [ -f "$f" ]; then
    if [ -n "$ori" ] && [ -f "$ori" ]; then
      $cp "$f" "$pre"
    else
      $cp "$f" "$ori"
    fi
  fi
}

where () {
  case $SH in
    zsh) whence -p $@ ;;
    bash) type -P $@ ;;
    *) command -v $@ ;;
  esac
}

gen_shell_dot_profile () {
  local profile="$HOME/.${SH}_profile"
  local callrc="test -r \${HOME}/.${SH}rc && . \${HOME}/.${SH}rc"
  case $SH in
    bash) profile="$HOME/.bash_profile" ;;
    zsh) profile="$HOME/.zprofile"
         if on_darwin; then
           callrc="# test -r \${HOME}/.${SH}rc && . \${HOME}/.${SH}rc"
         fi
         ;;
    sh) profile="$HOME/.profile" ;;
  esac
  save_as "$profile"
  $printf "+ generate $profile ... "
  $cat << EOF > "$profile"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# file: $profile
# target: call .${SH}rc
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
$(if [ -f "${profile}.ori" ]; then
  echo "# origin backup: ${profile}.ori"
fi)
#------------------------------------------------

${callrc}

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_dot_logout () {
  local f="$HOME/.${SH}_logout"
  if [ "zsh" = "$SH" ]; then
    f="$HOME/.zlogout"
  fi
  save_as "$f"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# file: $f
# target: call when logout
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
$(if [ -f "${f}.ori" ]; then
  echo "# origin backup: ${f}.ori"
fi)
$(if [ -f "${f}.pre" ]; then
  echo "# previous backup: ${f}.pre"
fi)
#------------------------------------------------

# \$($basename ${SH}): executed by ${SH}(1) when login shell exits.
# when leaving the console clear the screen to increase privacy

if [ "\$o_check_logout_env" = "yes" -a "\$SHLVL" -eq 1 ]; then
  clear
fi

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_dot_rc () {
  local rc="$HOME/.${SH}rc"
  local ss="# nore
[ -f \$HOME/.nore/${SH}/init ] && . \$HOME/.nore/${SH}/init

# eof
"
  save_as "$rc"
  $printf "+ generate $rc ... "
  if [ ! -f "$rc" ]; then
    $cat << EOF > "$rc"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# file: $rc
# target: .${SH}rc default
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
$(if [ -f "${rc}.ori" ]; then
  echo "# origin backup: ${rc}.ori"
fi)
$(if [ -f "${rc}.pre" ]; then
  echo "# previous backup: ${rc}.pre"
fi)
#------------------------------------------------

${ss}
EOF
  else
    $sed -i.pre '/^# nore/,/^# eof/d' $rc
    $printf "%s" "$ss" >> $rc
  fi
  echo_yes_or_no $?
}

gen_shell_init () {
  local idir="$HOME/.nore/${SH}"
  local init="${idir}/init"
  [ -d "$idir" ] || mkdir -p "$idir"
  $printf "+ generate $init ... "
  $cat << EOF > "$init"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# file: $init
# target: initialize ${idir}/* scripts
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

SHELL=$SHELL

where () {
  # check the path of non-builtins
  $(if [ "zsh" = "$SH" ]; then
    echo "whence -p \$@"
  elif [ "bash" = "$SH" ]; then
    echo "type -P \$@"
  else
    echo "command -v \$@"
  fi)
}

exist_p () {
  # check the existence of non-builtins
  where \$1 >/dev/null 2>&1
}

inside_container_p () {
  [ ".\$INSIDE_CONTAINER" = ".1" ] && return 0
  if [ "\${container}" = "podman" ]; then
    export INSIDE_CONTAINER=1
    return 0
  fi
  if [ -f /proc/1/cgroup ]; then
    if $cat /proc/1/cgroup | $grep -q '/docker/'; then
      export INSIDE_CONTAINER=1
      return 0
    fi
  fi
  export INSIDE_CONTAINER=0
  return 1
}

inside_emacs_p () {
  [ -n "\$INSIDE_EMACS" ]
}

inside_vim_p () {
  [ -n "\$VIMRUNTIME" ]
}

[ -f \$HOME/.nore/${SH}/vars ] && . \$HOME/.nore/${SH}/vars
[ -f \$HOME/.nore/${SH}/check ] && . \$HOME/.nore/${SH}/check

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_alias_env () {
  local f="$HOME/.nore/${SH}/alias_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

alias ..1='cd ../'
alias ..2='cd ../../'
alias ..3='cd ../../../'
alias ..4='cd ../../../../'

alias grep='grep --color=auto'
alias fgrep='grep -F --color=auto'

$(if on_darwin; then
  echo "alias ls='ls -G'"
  echo "alias ll='ls -lh -G'"
  echo "alias tailf='tail -f'"
  echo "# alias stat='stat -x'"
else
  echo "alias ls='ls --color=auto'"
  echo "alias ll='ls -lh --color=auto'"
  echo "alias l='ls -CF --color=auto'"
fi)

alias_emacs () {
  if exist_p emacs; then
    alias emacs='emacs -nw'
  fi
}

alias_rlwrap_bin () {
  local bin=\$1
  if exist_p \$bin; then
    alias \$bin="rlwrap \$bin"
  fi
}

alias_emacs

$(if on_linux && [ "$SH" = "bash" ]; then
   echo "# bsd ps style"
   echo "alias ps='ps w'"
fi)

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_sys_env () {
  local f="$HOME/.nore/${SH}/sys_env"
  local rc=0
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

# utc
sys_date_from_epoch () {
  local fmt="+%Y-%m-%d %H:%M:%S"
$(if on_linux; then
  $printf "  if [ \$# -eq 0 ]; then\n"
  $printf "    date -u -d@0 \"\$fmt\"\n"
  $printf "  else\n"
  $printf "    date -u -d@\$@ \"\$fmt\"\n"
  $printf "  fi\n"
elif on_darwin; then
  $printf "  if [ \$# -eq 0 ]; then\n"
  $printf "    date -u -r0 \"\$fmt\"\n"
  $printf "  else\n"
  $printf "    date -u -r\$@ \"\$fmt\"\n"
  $printf "  fi\n"
else
  $printf "  return 1\n"
fi)
}

sys_date_to_epoch () {
  local fmt="%Y-%m-%d %H:%M:%S"
  local out="+%s"
$(if on_linux; then
  $printf "  if [ \$# -eq 0 ]; then\n"
  $printf "    date -u \"\$out\"\n"
  $printf "  else\n"
  $printf "    date -u -d\"\$@\" \"\$out\"\n"
  $printf "  fi\n"
elif on_darwin; then
  $printf "  if [ \$# -eq 0 ]; then\n"
  $printf "    date -u \"\$out\"\n"
  $printf "  else\n"
  $printf "    date -u -j -f\"\$fmt\" \"\$@\" \"\$out\"\n"
  $printf "  fi\n"
else
  $printf "  return 1"
fi)
}

sys_os_release () {
$(if on_darwin; then
  $printf "  sw_vers\n"
elif on_linux; then
  $printf "  if [ -f \"/etc/os-release\" ]; then\n"
  $printf "    cat /etc/os-release\n"
  $printf "  fi\n"
elif on_windows_nt; then
  $printf "  systeminfo | grep '^OS Version'\n"
else
  $printf "  return 1\n"
fi)
}

sys_outbound_ip () {
  local u="https://checkip.dns.he.net"
  local v=\$1
  if exist_p curl; then
    case \$v in
      -6) v="-6" ;;
      *) v="-4" ;;
    esac
    curl \$v -sL "\$u" \\
      | $sed -n '/^Your IP.*/s;^Your IP.* \([.:a-z0-9]*\)</body>\$;\1;p'
  fi
}

sys_random_range () {
   local n=\${1:-8}
   $dd if=/dev/urandom count=\$(( n*4 )) bs=1 2>/dev/null \\
     | $iconv -c -t ascii//TRANSLIT 2>/dev/null \\
     | $tr -cd '[:print:]' \\
     | $cut -c 1-\$n
}

# Doug McIlroy
sys_word_frequency () {
  $tr -cs A-Za-z\' '\n' \\
    | $tr A-Z a-z \\
    | $sort \\
    | $uniq -c \\
    | $sort -k1,1nr -k2 \\
    | $sed \${1:-24}q
}

$(if on_darwin; then
  $printf "sys_xkill () {\n"
  $printf "  pbcopy \$@\n"
  $printf "}\n"
  $printf "\n"
  $printf "sys_xyank () {\n"
  $printf "  pbpaste \$@\n"
  $printf "}\n"
fi)

$(if on_linux && $printf "\$DISPLAY\n"|grep -q ':0\$'; then
  $printf "sys_xkill () {\n"
  $printf "  xsel --clipboard --input \$@\n"
  $printf "}\n"
  $printf "\n"
  $printf "sys_xyank () {\n"
  $printf "  xsel --clipboard --output \$@\n"
  $printf "}\n"
fi)

$(if on_darwin; then
  $printf "sys_find_unwanted () {\n"
  $printf "   local what=\"\$@\"\n"
  $printf "   local app_dir=\"/Applications\"\n"
  $printf "   local sup_dir=\"~/Library/Application Support\"\n"
  $printf "   local str_dir=\"~/Library/Saved Application State\"\n"
  $printf "   local cch_dir1=\"/Library/Caches\"\n"
  $printf "   local cch_dir2=\"~/Library/Caches\"\n"
  $printf "   local prf_dir=\"~/Library/Preferences\"\n"
  $printf "   local plg_dir=\"~/Library/Internet Plug-Ins\"\n"
  $printf "   local crs_dir=\"~/Library/Application Support/CrashReporter\"\n"
  $printf "   local lib_dir1=\"/Library\"\n"
  $printf "   local lib_dir2=\"~/Library\"\n"
  $printf "   $printf \"check \$app_dir ...\\\n\"\n"
  $printf "   $printf \"check \$sup_dir ...\\\n\"\n"
  $printf "   $printf \"check \$str_dir ...\\\n\"\n"
  $printf "   $printf \"check \$cch_dir2 ...\\\n\"\n"
  $printf "   $printf \"check \$cch_dir1 ...\\\n\"\n"
  $printf "   $printf \"check \$prf_dir ...\\\n\"\n"
  $printf "   $printf \"check \$plg_dir ...\\\n\"\n"
  $printf "   $printf \"check \$crs_dir ...\\\n\"\n"
  $printf "   $printf \"check \$lib_dir2 ...\\\n\"\n"
  $printf "   $printf \"check \$lib_dir1 ...\\\n\"\n"
  $printf "}\n"
fi)

$(if on_linux && where snap >/dev/null 2>&1; then
  $printf "snap_remove_disabled () {\n"
  $printf "  LANG=C snap list --all | $awk '/disabled/{print \$1, \$3}' |\n"
  $printf "    while read snapname revision; do\n"
  $printf "      sudo snap remove \"\$snapname\" --revision=\"\$revision\"\n"
  $printf "    done\n"
  $printf "}\n"
  $printf "\n"
  $printf "snapd_disable ()\n"
  $printf "{\n"
  $printf "  sudo systemctl stop snapd\n"
  $printf "  sudo systemctl disable snapd\n"
  $printf "}\n"
  $printf "\n"
  $printf "snapd_enable ()\n"
  $printf "{\n"
  $printf "  sudo systemctl enable snapd\n"
  $printf "  sudo systemctl restart snapd\n"
  $printf "}\n"
fi)

$(if on_linux && where unzip >/dev/null 2>&1; then
  $printf "unzip_zhcn () {\n"
  $printf "  unzip -Ogb2312 \$@\n"
  $printf "}\n"
fi)

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_vars () {
  local vdir="$HOME/.nore/${SH}"
  local f="${vdir}/vars"
  save_as "$f"
  local fb="${vdir}/.vars"
  local fbuf="${fb}.buf"
  local fnew="${fb}.new"
  local fold="${fb}.old"
  local fent="${fb}.ent"
  $cat <<EOF>"$fnew"
o_check_prompt_env=yes
o_check_completion_env=yes
o_check_locale_env=yes
o_check_logout_env=no
o_check_path_env=yes
o_check_sys_env=yes
o_check_alias_env=no
o_check_c_env=no
o_check_font_env=no
o_check_java_env=no
o_check_javascript_env=no
o_check_kube_env=no
o_check_latex_env=no
o_check_llvm_env=no
o_check_lisp_env=no
o_check_oracle_env=no
o_check_pandoc_env=yes
o_check_podman_env=no
o_check_printer_env=no
o_check_python_env=no
o_check_racket_env=no
o_check_rust_env=no
o_check_secure_env=no
o_check_tesseract_env=no
$(if on_darwin; then
  echo "o_check_macports_env=yes"
else
  echo "o_check_macports_env=no"
fi)
o_export_libpath_env=no
o_export_path_env=yes
EOF
  $cat </dev/null > "$fbuf"
  if [ -f "$f" ]; then
    $cat "$fnew"|$sed -n 's/^\(o_.*_env\)=.*$/\1/p' > "$fent"
    $cat "$f"|$sed -n 's/^\(o_.*_env\)=.*$/\1/p' > "$fold"
    $grep -f "$fent" "$f" 2>/dev/null >> "$fbuf"
    $grep -vf "$fold" "$fnew" 2>/dev/null >> "$fbuf"
  fi
  if ! $grep -q '^o_.*_env=.*$' "$fbuf"; then
    $cp "$fnew" "$fbuf"
  fi
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
$(if [ -f "${f}.ori" ]; then
  echo "# origin backup: ${f}.ori"
fi)
$(if [ -f "${f}.pre" ]; then
  echo "# previous backup: ${f}.pre"
fi)
#------------------------------------------------

$($cat "${fbuf}"|$sort|$uniq)

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_check () {
  local h="$HOME/.nore/${SH}"
  local f="${h}/check"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

if [ "\$o_check_path_env" = "yes" ]; then
  [ -f "${h}/path_env" ] \\
    && . "${h}/path_env"
fi

if [ "\$o_check_prompt_env" = "yes" ]; then
  [ -f "${h}/prompt_env" ] \\
    && . "${h}/prompt_env"
fi

if [ "\$o_check_locale_env" = "yes" ]; then
  [ -f "${h}/locale_env" ] \\
    && . "${h}/locale_env"
fi

if [ "\$o_check_completion_env" = "yes" ]; then
  [ -f "${h}/completion_env" ] \\
    && . "${h}/completion_env"
fi

if [ "\$o_check_sys_env" = "yes" ]; then
  [ -f "${h}/sys_env" ] \\
    && . "${h}/sys_env"
fi

if [ "\$o_check_alias_env" = "yes" ]; then
  [ -f "${h}/alias_env" ] \\
    && . "${h}/alias_env"
fi

if [ "\$o_check_bun_env" = "yes" ]; then
  [ -f "${h}/bun_env" ] \\
    && . "${h}/bun_env"
fi

if [ "\$o_check_c_env" = "yes" ]; then
  [ -f "${h}/c_env" ] \\
    && . "${h}/c_env"
fi

if [ "\$o_check_font_env" = "yes" ]; then
  [ -f "${h}/font_env" ] \\
    && . "${h}/font_env"
fi

if [ "\$o_check_java_env" = "yes" ]; then
  [ -f "${h}/java_env" ] \\
    && . "${h}/java_env"
fi

if [ "\$o_check_javascript_env" = "yes" ]; then
  [ -f "${h}/javascript_env" ] \\
    && . "${h}/javascript_env"
fi

if [ "\$o_check_kube_env" = "yes" ]; then
  [ -f "${h}/kube_env" ] \\
    && . "${h}/kube_env"
fi

if [ "\$o_check_latex_env" = "yes" ]; then
  [ -f "${h}/latex_env" ] \\
    && . "${h}/latex_env"
fi

if [ "\$o_check_llvm_env" = "yes" ]; then
  [ -f "${h}/llvm_env" ] \\
    && . "${h}/llvm_env"
fi

if [ "\$o_check_lisp_env" = "yes" ]; then
  [ -f "${h}/lisp_env" ] \\
    && . "${h}/lisp_env"
fi

if [ "\$o_check_macports_env" = "yes" ]; then
  [ -f "${h}/macports_env" ] \\
    && . "${h}/macports_env"
fi

if [ "\$o_check_oracle_env" = "yes" ]; then
  [ -f "${h}/oracle_env" ] \\
    && . "${h}/oracle_env"
fi

if [ "\$o_check_pandoc_env" = "yes" ]; then
  [ -f "${h}/pandoc_env" ] \\
    && . "${h}/pandoc_env"
fi

if [ "\$o_check_podman_env" = "yes" ]; then
  [ -f "${h}/podman_env" ] \\
    && . "${h}/podman_env"
fi

if [ "\$o_check_printer_env" = "yes" ]; then
  [ -f "${h}/printer_env" ] \\
    && . "${h}/printer_env"
fi

if [ "\$o_check_python_env" = "yes" ]; then
  [ -f "${h}/python_env" ] \\
    && . "${h}/python_env"
fi

if [ "\$o_check_racket_env" = "yes" ]; then
  [ -f "${h}/racket_env" ] \\
    && . "${h}/racket_env"
fi

if [ "\$o_check_rust_env" = "yes" ]; then
  [ -f "${h}/rust_env" ] \\
    && . "${h}/rust_env"
fi

if [ "\$o_check_secure_env" = "yes" ]; then
  [ -f "${h}/secure_env" ] \\
    && . "${h}/secure_env"
fi

if [ "\$o_check_tesseract_env" = "yes" ]; then
  [ -f "${h}/tesseract_env" ] \\
    && . "${h}/tesseract_env"
fi

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_path_env () {
  local f="$HOME/.nore/${SH}/path_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

norm_path() {
  echo \$1 \\
    | $tr ':' '\n' \\
    | $sed '/^$/d' \\
    | $tr '\n' ':' \\
    | $sed 's_:*\$__'
}

uniq_path() {
  $printf "\$*" \\
    | $awk -v RS=':' '\$0 && !a[\$0]++{printf "%s:",\$0}' \\
    | $sed 's_:*\$__'
}

rm_path() {
  local pd="\$(norm_path \$1)"
  local ph="\$(norm_path \$2)"
  if [ -z "\$pd" -o -z "\$ph" ]; then
    return 1
  fi
  local pr=\$(echo \$ph \\
              | $tr ':' '\n' \\
              | $grep -v "^\${pd}\$" \\
              | $tr '\n' ':' \\
              | $sed 's_:*\$__')
  $printf "%s\n" \$pr
}

posix_path() {
  local car=\$(echo \$@ | $cut -d ':' -f1 | $sed 's#\\\\#\/#g')
  local cdr=\$(echo \$@ | $cut -d ':' -f2 | $sed 's#\\\\#\/#g')
  if [ \${#car} -lt \${#cdr} ]; then
    car=\$(echo \$car | $tr '[:upper:]' '[:lower:]')
    $(if on_windows_nt; then
      echo "cdr=/\${car}\${cdr}"
    else
      echo "cdr=\${car}:\${cdr}"
    fi)
  fi
  echo \${cdr}
}

check_opt_dir () {
  $(if on_windows_nt; then
    echo "  if [ -d \"\/d\" ]; then"
    echo "    [ -d \"/d/opt/nore\" ] || $mkdir -p \"/d/opt/nore\""
    echo "    echo \"/d/opt/nore\""
    echo "  else"
    echo "    [ -d \"/c/opt/nore\" ] || $mkdir -p \"/c/opt/nore\""
    echo "    echo \"/c/opt/nore\""
    echo "  fi"
  else
    echo "  [ -d \"/opt/nore\" ] && echo \"/opt/nore\""
  fi)
}

$(if on_windows_nt; then
  echo "sort_path () {"
  echo "  # let MSYS_NT and user defined commands first"
  echo "  local ps=\$@"
  echo "  local opt_p=\$(check_opt_dir)/bin"
  echo "  local win_p='^/c/'"
  echo "  local opt="
  echo "  local ori="
  echo "  local win="
  echo "  local sorted="
  echo "  opt=\$($printf \"\${ps}\"|$tr ':' '\n'|$grep \"\$opt_p\"|$tr '\n' ':')"
  echo "  ori=\$($printf \"\${ps}\"|$tr ':' '\n'|$grep -v \"\$opt_p\"|$grep -v \"\$win_p\" | $tr '\n' ':')"
  echo "  win=\$($printf \"\${ps}\"|$tr ':' '\n'|$grep \"\$win_p\" | $tr '\n' ':')"
  echo "  sorted=\$($printf \"\${ori}\${opt:+\$opt }\${win}\""
  echo "  $printf \"\${sorted}\""
  echo "}"
fi)

export_path_env () {
  local bin_path="\${PATH}:${PH}"
  $(if on_darwin; then
    echo "local lib_path=\"\$DYLD_LIBRARY_PATH\""
  else
    echo "local lib_path=\"\$LD_LIBRARY_PATH\""
  fi)
  local opt_path="\$(check_opt_dir)"
  bin_path="\${opt_path}/bin:\${opt_path}/sbin:\$bin_path"
  lib_path="\${opt_path}/lib:\$lib_path"

  $(if on_windows_nt; then
    echo "bin_path=\"$(sort_path \$bin_path)\""
  fi)
  local p=""
  # export path env
  if [ "\$o_check_path_env" = "yes" ]; then
    p="\$(norm_path \$(uniq_path \$bin_path))"
    [ -z "\$p" ] || export PATH="\$p"
  fi
  # export libpath env
  if [ "\$o_export_libpath_env" = "yes" ]; then
    $(if on_darwin; then
      p="\"\$(norm_path \$(uniq_path \${lib_path}))\""
      echo "[ -z \"\$p\" ] || export DYLD_LIBRARY_PATH=\"\$p\""
    else
      p="\"\$(norm_path \$(uniq_path \${lib_path}))\""
      echo "[ -z \"\$p\" ] || export LD_LIBRARY_PATH=\"\$p\""
    fi)
  fi
}

export_path_env

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_prompt_env () {
  local f="$HOME/.nore/${SH}/prompt_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

pretty_prompt_command () {
  local o="\${PROMPT_COMMAND}"
  local pc1=''

  if [ -n "\${o}" ]; then
    if inside_container_p || inside_emacs_p; then
      echo "\$pc1"
      return 0
    fi
  fi
  echo "\$o"
  return 1
}

pretty_term () {
  local o="\$TERM"
  local t="xterm"

  if [ -z "\$o" ]; then
    echo "\$t"
    return 0
  fi

  if [ "dumb" = "\$o" ]; then
    if inside_emacs_p; then
      echo "\$o"
    else
      echo "\$t"
    fi
  else
    echo "\$o"
  fi
}

check_prompt_env () {
  PROMPT_COMMAND="\$(pretty_prompt_command)"
  if [ -z "\$PROMPT_COMMAND" ]; then
    unset PROMPT_COMMAND
  else
    export PROMPT_COMMAND
  fi
$(if [ "zsh" = "$SH" ]; then
  echo "  PS1=\"%n@%m %1~ %#\""
elif [ "bash" = "$SH" ]; then
  echo "  PS1=\"\u@\h \W \$\""
else
  echo "  PS1=\"\$LOGNAME@\$($uname -n | $cut -d '.' -f1) \$\""
fi)
  export PS1="\${PS1% } "
  TERM="\$(pretty_term)"
  export TERM
}

# eof
EOF
  echo_yes_or_no $?
}

gen_shell_locale_env () {
  local f="$HOME/.nore/${SH}/locale_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

export_locale_env () {
$(if on_windows_nt; then
  $printf "  # change code page to unicode\n"
  $printf "  chcp.com 65001 &>/dev/null\n"
  $printf "  if locale -a | grep -qF 'en_US.utf8'\n"
  $printf "    export LANG=en_US.utf8\n"
  $printf "  fi\n"
elif on_darwin; then
  $printf "  if locale -a | grep -qF 'en_US.UTF-8'; then\n"
  $printf "    export LANG=en_US.UTF-8\n"
  $printf "  fi\n"
elif on_linux; then
  $printf "  # sudo dpkg-reconfigure locales\n"
  $printf "  if locale -a | grep -qF 'en_US.utf8'; then\n"
  printf "     export LANG=en_US.utf8\n"
  $printf "  fi\n"
fi)
}

export_locale_env
# eof
EOF
  echo_yes_or_no $?
}

gen_shell_completion_env () {
  local f="$HOME/.nore/${SH}/completion_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

check_completion_env () {
$(if [ "bash" = "$SH" ]; then
   echo "  local c=\"/etc/profile.d/bash_completion.sh\""
   echo "  if [ -f \"\$c\" ]; then"
   echo "    . \"\$c\""
   echo "  fi"
elif [ "zsh" = "$SH" ]; then
   echo "  autoload -Uz compinit && compinit"
else
   echo "  # nop"
   echo ":"
fi)
}

check_completion_env

# eof
EOF
  echo_yes_or_no $?
}

gen_c_env () {
  local f="$HOME/.nore/${SH}/c_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://github.com/junjiemars/nore
#------------------------------------------------

check_c_nore_env () {
  local d="\$HOME/.nore"
  if [ -x "\${d}/cc-env.sh" ]; then
    return 0
  fi
  return 1
}

install_c_nore_env () {
  curl https://raw.githubusercontent.com/junjiemars/nore/master/bootstrap.sh -sSfL | sh
}

install_c_sys_env () {
$(if on_darwin; then
  $printf "  xcode-select --install\n"
elif on_linux; then
  $printf "  if command -v apt &>/dev/null; then\n"
  $printf "    sudo apt install build-essential manpages-posix manpages-posix-dev\n"
  $printf "  elif command -v yum &>/dev/null; then\n"
  $printf "    sudo yum group install \"Development Tools\"\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
else
  $printf "  :\n"
fi)
}

install_c_autotools_env () {
$(if on_darwin; then
  $printf "  if command -v port &>/dev/null; then\n"
  $printf "    sudo port install autoconf automake libtool\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
elif on_linux; then
  $printf "  if command -v apt &>/dev/null; then\n"
  $printf "    sudo apt install autotools-dev\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
else
  $printf "  :\n"
fi)
}

install_c_gcc_aarch64_env () {
$(if on_darwin; then
  $printf "  :\n"
elif on_linux; then
  $printf "  if command -v apt &>/dev/null; then\n"
  $printf "    sudo apt install gcc-aarch64-linux-gnu\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
else
  $printf "  :\n"
fi)
}

install_c_lsp_env () {
$(if on_darwin; then
  $printf "  if command -v port &>/dev/null; then\n"
  $printf "    sudo port install clang-12 bear\n"
  $printf "  fi\n"
elif on_linux; then
  $printf "  if command -v apt &>/dev/null; then\n"
  $printf "    sudo apt install clang-12 bear\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
else
  $printf "  :\n"
fi)
}

install_c_cmake_env () {
$(if on_darwin; then
  $printf "  if command -v port &>/dev/null; then\n"
  $printf "    sudo port install cmake\n"
  $printf "  fi\n"
elif on_linux; then
  $printf "  if command -v apt &>/dev/null; then\n"
  $printf "    sudo apt install cmake\n"
  $printf "  else\n"
  $printf "    :\n"
  $printf "  fi\n"
else
  $printf "  :\n"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_font_env () {
  local f="$HOME/.nore/${SH}/font_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

list_font_mono () {
  $printf "https://gitlab-org.gitlab.io/frontend/fonts/fonts/GitLabMono.ttf\n"
  $printf "https://gitlab-org.gitlab.io/frontend/fonts/fonts/GitLabMono-Italic.ttf\n"
}

list_font_sans () {
  $printf "https://gitlab-org.gitlab.io/frontend/fonts/fonts/GitLabSans.ttf\n"
  $printf "https://gitlab-org.gitlab.io/frontend/fonts/fonts/GitLabSans-Italic.ttf\n"
}

install_font_file () {
  local d="\$1"
  if [ -z "\$d" ]; then
    return 1
  fi
$(if on_darwin; then
  $printf "  cp \"\$d\" ~/Library/Fonts/\n"
elif on_linux; then
  $printf "  cp \"\$d\" ~/.fonts/\n"
  $printf "  fc-cache -f\n"
else
  $printf "  :\n"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_java_env () {
  local f="$HOME/.nore/${SH}/java_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://openjdk.java.net
#------------------------------------------------

check_java_env () {
  local javac="\$(where javac 2>/dev/null)"
  if ! \$javac -version &>/dev/null; then
    return 1
  fi
  $printf "%s\n" "\$javac"
}

export_java_env () {
  local javac="\${1:-\$(check_java_env)}"
  local d="\$(dirname \$javac)"
  local java="\${d}/java"
  unset JAVA_HOME
  if ! "\$java" -version &>/dev/null; then
    return 1
  fi
$(if on_darwin; then
  echo "  d=\"\$(/usr/libexec/java_home 2>/dev/null)\""
  echo "  # filter version: /usr/libexec/java_home -F -v 17"
  echo "  if [ ! -d \"\$d\" ]; then"
  echo "    return 1"
  echo "  fi"
  echo "  export JAVA_HOME=\"\$d\""
elif on_linux; then
  echo "  if [ -L \"\$javac\" ]; then"
  echo "    d=\"\$(dirname \$(readlink -f \"\$javac\"))\""
  echo "    if [ ! -d \"\$d\" ]; then"
  echo "      return 1"
  echo "    fi"
  echo "  fi"
  echo "  export JAVA_HOME=\"\$(dirname \$d)\""
else
  echo "  export JAVA_HOME=\"\$(dirname \$d)\""
fi)
  local p="\$PATH"
  p="\$(norm_path \$d:\$(rm_path \$d \$p))"
  [ -z "\$p" ] || export PATH="\$p"
}

select_java_env () {
  local javac="\$1"
  if [ ! -x "\$javac" ]; then
    return 1
  fi
  export_java_env "\$javac"
}

select_java_gradle_env() {
  local gradle="\$1"
  if [ ! -x "\$gradle" ]; then
    return 1
  fi
  local opt_bin="\$(check_opt_dir)/bin"
  if [ ! -d "\$opt_bin" ]; then
    return 1
  fi
  local gradle_sh="\${opt_bin}/gradle"
  cat <<END>"\$gradle_sh"
#!$SHELL
\$gradle \\\$@
END
  $chmod u+x "\$gradle_sh"
}

make_java_lsp () {
  # download jdtls from http://download.eclipse.org/jdtls/milestones/
  local jdtls="\$1"
  if [ ! -x "\$jdtls" ]; then
    return 1
  fi
  # config
  # generate startup script
  : #nop
}

make_java_maven_settings () {
  cat <<END>/dev/stdout
<settings xmlns="http://maven.apache.org/SETTINGS/1.2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.2.0 http://maven.apache.org/xsd/settings-1.2.0.xsd">
  <localRepository>${HOME}/.m2/repository</localRepository>
  <!--
  <servers>
    <server>
      <id>maven-http-local-public</id>
      <username>username1</username>
      <password>password1</password>
    </server>
    <server>
      <id>maven-http-local-snapshots</id>
      <username>username1</username>
      <password>password1</password>
    </server>
  </servers>
  -->
  <mirrors>
    <mirror>
      <!--This sends everything else to /public -->
      <id>nexus</id>
      <mirrorOf>*</mirrorOf>
      <url>https://maven.aliyun.com/nexus/content/groups/public</url>
    </mirror>
  </mirrors>
  <profiles>
    <profile>
      <id>XXX</id>
      <!--Enable snapshots for the built in central repo to direct -->
      <!--all requests to nexus via the mirror -->
      <repositories>
        <repository>
          <id>nexus</id>
          <name>Team Nexus Repository</name>
          <url>https://maven.aliyun.com/nexus/content/groups/public</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>false</enabled></snapshots>
        </repository>
        <repository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>false</enabled></snapshots>
        </repository>
      </repositories>
      <!--
      <repository>
        <id>nexus_private_repo1</id>
        <name>Private Nexus Respository</name>
        <url>http://192.168.2.238:8080/repo_new/</url>
        <releases><enabled>true</enabled></releases>
        <snapshots><enabled>true</enabled></snapshots>
      </repository>
      -->
      <pluginRepositories>
      </pluginRepositories>
    </profile>
  </profiles>
  <activeProfiles>
    <activeProfile>XXX</activeProfile>
  </activeProfiles>
</settings>
END
}

# eof
EOF
  echo_yes_or_no $?

}

gen_kube_env () {
  local f="$HOME/.nore/${SH}/kube_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://kubernetes.io/docs/reference/kubectl/overview/
# https://argoproj.github.io/argo-workflows/
#------------------------------------------------

check_kube_env () {
  local d="\${HOME}/.kube"
  local s="\${d}/kube-${SH}.sh"
  local a="\${d}/argo-${SH}.sh"
  local c="\${d}/\${1}"
  local r="\${d}/.recent"
  if exist_p kubectl; then
    if [ ! -f "\$s" ]; then
      [ -d "\$d" ] || mkdir -p "\$d"
      SHELL=$SHELL kubectl completion ${SH} >"\$s"
    fi
    if [ -r "\$s" ]; then
      check_completion_env && . "\$s"
    fi
    if [ -f "\$c" ]; then
      export KUBECONFIG="\$c"
      $cp "\$c" "\$r"
    elif [ -f "\$r" ]; then
      export KUBECONFIG="\$r"
    fi
    if inside_emacs_p && exist_p emacsclient; then
      export KUBE_EDITOR=emacsclient
    fi
  else
    return 1
  fi
  if exist_p argo; then
    if [ ! -f "\$a" ]; then
      SHELL=$SHELL argo completion ${SH} >"\$a"
    fi
    if [ -r "\$a" ]; then
      check_completion_env && . "\$a"
    fi
  fi
  return 0
}

# eof
EOF
  echo_yes_or_no $?
}

gen_latex_env () {
  local f="$HOME/.nore/${SH}/latex_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://www.latex-project.org
#------------------------------------------------

install_latex_texlive () {
$(if on_darwin; then
  $printf "  sudo port install texlive-latex-recommented\n"
elif on_linux; then
  $printf "  sudo apt install texlive-latex-recommented\n"
else
  $printf "  :\n"
fi)
}

install_latex_lsp () {
$(if on_darwin; then
  $printf "  sudo port install texlive-latex-recommented texlive-xetex texlive-lang-cjk texlab\n"
elif on_linux; then
  $printf "  sudo apt install install texlive-latex-recommented texlive-xetex texlive-lang-cjk texlab\n"
else
  $printf "  :\n"
fi)
}

install_latex_org_mode () {
$(if on_darwin; then
  $printf "  sudo port install texlive-latex-extra dvipng\n"
elif on_linux; then
  $printf "  sudo apt install install texlive-latex-extra dvipng\n"
else
  $printf "  :\n"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_llvm_env () {
  local f="$HOME/.nore/${SH}/llvm_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://llvm.org
#------------------------------------------------

# https://clangd.llvm.org/installation
check_llvm_clangd () {
  if clangd --version &>/dev/null; then
    return 0
  fi
$(if on_darwin; then
  echo "  echo \"sudo port install clang-12\""
elif on_linux; then
  echo "  echo \"sudo apt install clang-12\""
else
  echo "  :"
fi)
  return 1
}

# https://github.com/rizsotto/Bear?tab=readme-ov-file
check_bear () {
  if bear --version &>/dev/null; then
    return 0
  fi
$(if on_darwin; then
  echo "  echo \"sudo port install bear\""
elif on_linux; then
  echo "  echo \"sudo apt install bear\""
else
  echo "  :"
fi)
  return 1
}

# eof
EOF
  echo_yes_or_no $?
}

gen_lisp_env () {
  local f="$HOME/.nore/${SH}/lisp_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://lisp.org
#------------------------------------------------

check_lisp_env () {
  local lisp=\$1
  if [ -n "\$lisp" ]; then
    \$lisp --version &>/dev/null
    return
  fi
  return 1
}

# eof

install_lisp_chez () {
$(if on_darwin; then
  $printf "  sudo port install chez-scheme\n"
else
  $printf "  :\n"
fi)
}

install_lisp_sbcl () {
$(if on_darwin; then
  $printf "  sudo port install sbcl\n"
else
  $printf "  :\n"
fi)
}

EOF
  echo_yes_or_no $?
}

gen_macports_env () {
  local f="$HOME/.nore/${SH}/macports_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://www.macports.org
#------------------------------------------------

check_macports_env () {
  if [ ! -x "/opt/local/bin/port" ]; then
    return 1
  fi
  printf "%s\n" "/opt/local"
  return 0
}

check_macports_llvm_env () {
  local p="/opt/local/libexec/llvm"
  if [ ! -L "\$p" ]; then
    # sudo port install llvm-12
    return 1
  fi
  $printf "%s\n" "\$p"
  return 0
}

export_macports_path () {
  local h="\$(check_macports_env)"
  if [ -z "\$h" ]; then
    return 1
  fi
  local p=
  local o=
  o="\$(check_macports_llvm_env)"
  p="\$PATH"
  if [ -d "\${o}/bin" ]; then
    p="\${o}/bin:\$(rm_path \${o}/bin \$p)"
  fi
  if [ -d "\${h}/sbin" ]; then
    p="\$(norm_path \${h}/sbin:\$(rm_path \${h}/sbin \$p))"
  fi
  if [ -d "\${h}/bin" ]; then
    p="\$(norm_path \${h}/bin:\$(rm_path \${h}/bin \$p))"
  fi
  [ -z "\$p" ] || export PATH="\$p"
}

export_macports_libpath () {
  local h="\$(check_macports_env)"
  if [ -z "\$h" ]; then
    return 1
  fi
  local p=
  local o=
  o="\$(check_macports_llvm_env)"
  p="\$DYLD_LIBRARY_PATH"
  if [ -d "\${o}/lib" ]; then
    p="\$(norm_path \${o}/lib:\$(rm_path \${o}/lib \$p))"
  fi
  if [ -d "\${h}/lib" ]; then
    p="\$(norm_path \${h}/lib:\$(rm_path \${h}/lib \$p))"
  fi
  [ -z "\$p" ] || export DYLD_LIBRARY_PATH="\$p"
}

if [ "\$o_export_path_env" = "yes" ]; then
  export_macports_path
fi

if [ "\$o_export_libpath_env" = "yes" ]; then
  export_macports_libpath
fi

# eof
EOF
  echo_yes_or_no $?
}

gen_javascript_env () {
  local f="$HOME/.nore/${SH}/javascript_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://github.com/oven-sh/bun
# https://github.com/nvm-sh/nvm
#------------------------------------------------

check_bun_env () {
  local d="\$HOME/.bun"
  if [ -x "\${d}/bin/bun" ]; then
    BUN_DIR="\${d}/bin"
    return 0
  fi
  return 1
}

check_javascript_nvm_env () {
  local d="\$HOME/.nvm"
  if [ -s "\${d}/nvm.sh" ]; then
    JAVASCRIPT_NVM_DIR="\$d"
    . "\${d}/nvm.sh"
    $(if [ "bash" = "$SH" ]; then
      echo "[ -s \"\${d}/bash_completion\" ] && . \"\${d}/bash_completion\""
    fi)
    return 0
  fi
  return 1
}

install_javascript_nvm_sh() {
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
}

export_javascript_nvm_env () {
  if check_javascript_nvm_env; then
    local p="\$PATH"
    p="\$(norm_path \$d:\$(rm_path \$NM_DIR \$p))"
    [ -z "\$p" ] || export PATH="\$p"
  fi
}

# if [ "\$o_check_javascript_nvm_env" = "yes" ]; then
#   export_javascript_nvm_env
# fi

# eof
EOF
  echo_yes_or_no $?
}

gen_oracle_env () {
  local f="$HOME/.nore/${SH}/oracle_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://developer.oracle.com/
#------------------------------------------------

check_oracle_env () {
  :
}

export_oracle_env () {
  :
}

make_oracle_sqlplus_sh () {
  local s="\$1"
  if [ ! -x "\$s" ]; then
    return 1
  fi
  local opt_bin="\$(check_opt_dir)/bin"
  if [ ! -d "\$opt_bin" ]; then
    return 1
  fi
  local sqlplus_sh="\${opt_bin}/sqlplus.sh"
  cat <<END > "\$sqlplus_sh"
#!$SHELL
export ORACLE_HOME="\$(dirname \$s)"
$(if on_darwin; then
echo "export DYLD_LIBRARY_PATH=\"\$(dirname \$s)\""
else
echo "export LD_LIBRARY_PATH=\"\$(dirname \$s)\""
fi)
export NLS_LANG="\${NLS_PATH:-AMERICAN_AMERICA.UTF8}"
exec \$s \\\$@
END
  $chmod u+x "\$sqlplus_sh"
}

list_oracle_sample_schemas () {
  $printf "https://github.com/oracle-samples/db-sample-schemas\n"
}

if [ "\$o_check_oracle_env" = "yes" ]; then
  :
fi

# eof
EOF
  echo_yes_or_no $?
}

gen_pandoc_env () {
  local f="$HOME/.nore/${SH}/pandoc_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://pandoc.org
#------------------------------------------------

check_pandoc_env () {
  if ! pandoc -v &>/dev/null; then
     return 1
  fi
}

install_pandoc () {
$(if on_darwin; then
  $printf "  # for full latex support +full_latex_dependencies\n"
  $printf "  sudo port install pandoc\n"
elif on_linux; then
  $printf "  sudo apt install pandoc\n"
elif on_windows_nt; then
  $printf "  choco install pandoc\n"
else
  $printf "  :"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_podman_env () {
  local f="$HOME/.nore/${SH}/podman_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://podman.io
#------------------------------------------------

check_podman_env () {
  if ! podman -v &>/dev/null; then
     return 1
  fi
  local r="\${HOME}/.config/registries.conf"
  [ -r "\$r" ] && $printf "%s\n" "\$(command -v podman)"
}

list_podman_registry () {
  $printf "%s\n" 'docker.io'
  $printf "%s\n" 'registry.access.redhat.com'
  $printf "%s\n" 'registry.redhat.io'
}

list_podman_config () {
$(if on_linux; then
  $printf "  local etc=\"%s\"\n" "/etc/containers/registeries.conf"
  $printf "  $printf \"%s %d\n\" \"\$etc\" \$(test -f \"\$etc\"; echo \$?)"
fi)
  local h="\${HOME}/.config/registries.conf"
  $printf "%s %d\n" "\$h" \$(test -f "\$h"; echo \$?)
  local p="\${HOME}/.config/containers/podman"
  $printf "%s %d\n" "\$p" \$(test -f "\$p"; echo \$?)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_printer_env () {
  local f="$HOME/.nore/${SH}/printer_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

install_printer_hp_env () {
$(if on_linux; then
  $printf "  sudo apt install hplip hplip-gui hplip-data hplip-doc\n"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_python_env () {
  local f="$HOME/.nore/${SH}/python_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://www.python.org
# https://virtualenv.pypa.io
# https://pypi.org/project/pip/
#------------------------------------------------

check_python_env () {
  local p3="\$(where python3 2>/dev/null)"
  if "\$p3" -V &>/dev/null; then
    $printf "%s\n" "\$p3"
    return 0
  fi
  p3="\$(where python 2>/dev/null)"
  if ! "\$p3" -V &>/dev/null; then
    return 1
  fi
  local v3="\$(\$p3 -V|sed 's/^Python \([0-9]*\)\..*$/\1/' 2>/dev/null)"
  [ "\$v3" -ge "3" ] && $printf "%s\n" "\$p3"
}

check_python_pip () {
  local p3="\$(where pip3 2>/dev/null)"
  if "\$p3" -V &>/dev/null; then
    $printf "%s\n" "\$p3"
    return 0
  fi
  p3="\$(where pip 2>/dev/null)"
  if ! "\$p3" -V &>/dev/null; then
    return 1
  fi
  local v3="\$(\$p3 -V|sed 's/.*(python \([0-9]*\)\..*).*/\1/' 2>/dev/null)"
  [ \$v3 -ge 3 ] && $printf "%s\n" "\$p3"
}

make_python_venv () {
  local d="\${1:-\$(pwd)}"
  local p="\$(check_python_env)"
  if [ -z "\$p" ]; then
    return 1
  fi
  \$p -m venv "\$d" && $printf "%s\n" "\$d"
}

list_python_pip_mirror () {
  $printf "%s\n" 'https://pypi.tuna.tsinghua.edu.cn/simple/'
  $printf "%s\n" 'https://pypi.mirrors.ustc.edu.cn/simple/'
  $printf "%s\n" 'http://mirrors.aliyun.com/pypi/simple/'
  $printf "%s\n" 'http://pypi.hustunique.com/'
  $printf "%s\n" 'http://pypi.sdutlinux.org/'
  $printf "%s\n" 'http://pypi.douban.com/simple/'
}

make_python_pip_mirror () {
  local m="\${1:-\$(check_python_pip_mirror|$sed -n '1p')}"
  local p="\$(check_python_pip)"
  if [ -z "\$p" ]; then
    return 1
  fi
  \$p config set global.index-url "\$m"
}

make_python_lsp () {
  local py="\$(check_python_env)"
  if [ -z "\$py" ]; then
    return 1
  fi
  local pip="\$(check_python_pip)"
  if [ -z "\$pip" ]; then
    return 1
  fi
  local opt_bin="\$(check_opt_dir)/bin"
  if [ ! -d "\$opt_bin" ]; then
    return 1
  fi
  if ! \$pip show python-lsp-server &>/dev/null; then
    \$pip install python-lsp-server
  fi
  local sr="\$(\$py -c'import sys;print(sys.prefix)' 2>/dev/null)"
  local pylsp="\${sr}/bin/pylsp"
  if [ ! -f "\$pylsp" ]; then
    return 1
  fi
  local ve="\${sr}/bin/activate"
  local pylsp_sh="\${opt_bin}/pylsp.sh"
  cat <<END > "\$pylsp_sh"
#!$SHELL
\$(if [ -f "\$ve" ]; then
  echo ". \"\$ve\""
fi)
exec \$pylsp \\\$@
END
  $chmod u+x "\$pylsp_sh"
$(echo "}")

make_python_http_server () {
  local p="\$(check_python_env)"
  if [ -z "\$p" ]; then
    return 1
  fi
  # \$p -m http.server -h
  \$p -m http.server \$@
}

# eof
EOF

  echo_yes_or_no $?
}

gen_racket_env () {
  local f="$HOME/.nore/${SH}/racket_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://racket-lang.org
#------------------------------------------------

check_racket_env () {
$(if on_darwin; then
   if [ "zsh" = "$SH" ]; then
      echo "  setopt +o nomatch &>/dev/null"
   fi
   echo "  if \$ls -ldr /Applications/Racket* &>/dev/null; then"
   echo "    RACKET_HOME=\"\$($ls -ldr /Applications/Racket* | $sed 1q | $sed 's;.*\(/Applications/Racket v[0-9][0-9]*\.[0-9][0-9]*\).*;\1;g')\""
   echo "  fi"
   if [ "zsh" = "$SH" ]; then
     echo "  setopt -o nomatch &>/dev/null"
   fi
   echo "  if [ -z \"\$RACKET_HOME\" ]; then"
   echo "    unset RACKET_HOME"
   echo "    return 1"
   echo "  fi"
else
   echo "  # nop"
   echo "  :"
fi)
}

# eof
EOF
  echo_yes_or_no $?
}

gen_rust_env () {
  local r="${HOME}/.nore/${SH}"
  local f="${r}/rust_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://www.rust-lang.org/
#------------------------------------------------

check_rust_env () {
  local rc="\${HOME}/.cargo/bin/rustc"
  if [ ! -x "\$rc" ]; then
    return 1
  fi
  local sr="\$(\$rc --print sysroot 2>/dev/null)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  [ -x "\$sr/bin/rustc" ] && $printf "%s\n" "\$sr"
}

install_rustup () {
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
}

list_rust_cargo_mirror () {
  $printf "%s %s\n" 'tuna' 'https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git'
  $printf "%s %s\n" 'ustc' 'https://mirrors.ustc.edu.cn/crates.io-index'
  $printf "%s %s\n" 'aliyun' 'https://mirrors.aliyun.com/crates.io-index'
}

make_rust_cargo_mirror () {
  local sr="\$(check_rust_env)"
  local c=""
  if [ -z "\$sr" ]; then
    return 1
  fi
  c="\${HOME}/.cargo/config.toml"
  cat <<END>"\$c"
[source.crates-io]
replace-with = '\$1'
[source.\$1]
registry = '\${2}/'
END
}

check_rust_completion () {
  local rc="${r}/rust_cargo_completion"
  local ru="${r}/rust_rustup_completion"
  rustup completions $SH cargo > \$rc
  rustup completions $SH rustup > \$ru
  . \$rc
  . \$ru
}

check_rust_etc () {
  local sr="\$(check_rust_env)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  local etc="\${sr}/lib/rustlib/etc"
  [ -d "\$etc" ] && echo "\$etc"
}

check_rust_src () {
  local sr="\$(check_rust_env)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  local src="\${sr}/lib/rustlib/src/rust"
  [ -d "\$src" ] && echo "\$src"
}

check_rust_hash () {
  local sr="\$(check_rust_env)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  local hash="\$(\${sr}/bin/rustc -vV|$sed -n '/^commit-hash/s;^commit-hash: \(.*\)$;\1;p' 2>/dev/null)"
  [ -n "\$hash" ] && echo "\$hash"
}

make_rust_debug () {
  local sr="\$(check_rust_env)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  local hash="\$(check_rust_hash)"
  if [ -z "\$hash" ]; then
    return 1
  fi
  local etc="\$(check_rust_etc)"
  if [ -z "\$etc" ]; then
    return 1
  fi
  local src="\$(check_rust_src)"
  if [ -z "\$src" ]; then
    return 1
  fi
  local gdb="\${etc}/gdb_load_rust_pretty_printers.py"
  local lldb="\${etc}/lldb_commands"
  local from="/rustc/\${hash}"
  if [ -f "\$gdb" ]; then
     if ! $grep -q 'set substitute-path' \$gdb; then
       $cp \$gdb \${gdb}.b0
     fi
     $sed -i.b1 '/set substitute-path/d' \$gdb
     $printf "gdb.execute('set substitute-path \$from \$src')" >> \$gdb
  fi
  if [ -f "\$lldb" ]; then
    if ! $grep -q 'settings set target.source-map' \$lldb; then
      $cp \$lldb \${lldb}.b0
    fi
    $sed -i.b1 '/settings set target\.source-map/d' \$lldb
    $printf "settings set target.source-map \$from \$src" >> \$lldb
  fi
}

check_rust_tags_option () {
  local etc="\$(check_rust_etc)"
  if [ -z "\$etc" ]; then
    return 1
  fi
  $printf "%s\n" "\${etc}/ctags.rust"
}

check_rust_tags_file () {
  local etc="\$(check_rust_etc)"
  if [ -z "\$etc" ]; then
    return 1
  fi
  $printf "%s\n" "\${etc}/.tags_emacs"
}

make_rust_tags () {
  local args="\$@"
  local sr="\$(check_rust_env)"
  if [ -z "\$sr" ]; then
    return 1
  fi
  local etc="\$(check_rust_etc)"
  if [ -z "\$etc" ]; then
    return 1
  fi
  local src="\$(check_rust_src)"
  if [ -z "\$src" ]; then
    return 1
  fi
  local tag_opt="\$(check_rust_tags_option)"
  if [ ! -f "\$tag_opt" ]; then
    local opt_src="https://raw.githubusercontent.com/rust-lang/rust/master/src/etc/ctags.rust"
    $mkdir -p "\${etc}"
    curl --proto '=https' --tlsv1.2 -sSf "\$opt_src" -o "\$tag_opt"
  fi
  if ! where ctags &>/dev/null; then
    return 1
  fi
  local d="\$(check_rust_tags_file)"
  [ -f "\$d" ] && rm "\$d"
  ctags \$args -R -e -o \$d --options="\$tag_opt" \$src
  $printf "%s\n" "\$d"
}

export_rust_env () {
  local h="\$(check_rust_env)";
  unset CARGO_HOME
  if [ -d "\$h" ]; then
    local o="\${HOME}/.cargo"
    local p="\$PATH"
    if [ -d "\${o}/bin" ]; then
      p="\$(norm_path \$(rm_path \${o}/bin \$p):\${o}/bin)"
      CARGO_HOME="\${o}"
    fi
    if [ -d "\${h}/bin" ]; then
      p="\$(norm_path \$(rm_path \${h}/bin \$p):\${h}/bin)"
    fi
    export PATH="\$p"
  fi
}

if [ "\$o_export_path_env" = "yes" ]; then
  export_rust_env
fi

if [ "\$o_check_completion_env" = "yes" ]; then
  : # check_rust_completion
fi

# eof
EOF
  echo_yes_or_no $?
}

gen_secure_env () {
  local r="${HOME}/.nore/${SH}"
  local f="${r}/secure_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
#------------------------------------------------

list_secure_source_site () {
  printf "chromium https://github.com/chromium/chromium\n"
  printf "firefox https://searchfox.org\n"
}

check_secure_tls () {
  curl -XGET -H'Content-Type: application/json' 'https://tls.browserleaks.com/tls'
}

# eof
EOF
  echo_yes_or_no $?
}

gen_tesseract_env () {
  local r="${HOME}/.nore/${SH}"
  local f="${r}/tesseract_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://github.com/tesseract-ocr/tesseract.git
#------------------------------------------------

check_tesseract_env () {
 :
}

install_tesseract () {
  # sudo port install tesseract tesseract-eng
 :
}

# eof
EOF
  echo_yes_or_no $?
}

gen_unix_env () {
  local r="${HOME}/.nore/${SH}"
  local f="${r}/unix_env"
  $printf "+ generate $f ... "
  $cat << EOF > "$f"
#### -*- mode:sh -*- vim:ft=sh
#------------------------------------------------
# target: $f
# author: Junjie Mars
# generated by:
#   $SH <($SH_ENV)
# https://github.com/mit-pdos/xv6-public.git
# https://github.com/mit-pdos/xv6-riscv.git
# https://github.com/rstallman/UNIX-System-V-Release-4-source-code.git
#------------------------------------------------

EOF
  echo_yes_or_no $?
}

gen_dot_exrc () {
  local rc="$HOME/.exrc"
  $printf "+ generate $rc ... "
  $cat << END > "$rc"
"------------------------------------------------
" target: $rc
" author: Junjie Mars
" generated by:
"   $SH <($SH_ENV)
$(if [ -f "${rc}.ori" ]; then
  echo "\" origin backup: ${rc}.ori"
fi)
"------------------------------------------------

set exrc

" nocompatible
"set nocompatible

" indent uses 2 characters
set shiftwidth=2

" tabs are 2 characters
set tabstop=2

" expand tab
"if has("autocmd")
"   set expandtab
"   autocmd FileType make set noexpandtab
"   autocmd FileType python set noexpandtab
"endif

" history
set history=50

" 1000 undo levels
set undolevels=1000

" encoding
"set encoding=utf8
set fileencoding=utf8

" line number
set nonumber

" syntax highlight
syntax enable

" highlight search
set hlsearch " :nohl

" background dark
set background=light

" keep filetype and syntax
set hidden " :nohidden

" status bar
set ruler
"set laststatus=2

" visual bell
set novisualbell

" shell
$(if [ "zsh" = "$SH" ]; then
  echo "\"set shell=zsh\ --rcs"
else
  echo "\"set shell=bash\ --rcfile\ ${HOME}/.bashrc"
fi)

" search subdirs
set path+=**

END
  echo_yes_or_no $?
}


BEGIN=$($date +%s)
echo "setup ${PLATFORM}'s $SH env ..."

gen_shell_dot_profile
gen_shell_dot_logout
gen_shell_dot_rc

gen_shell_init
gen_shell_vars
gen_shell_check

gen_shell_prompt_env
gen_shell_locale_env
gen_shell_completion_env
gen_shell_path_env
gen_shell_sys_env
gen_shell_alias_env

gen_c_env
gen_font_env
gen_java_env
gen_javascript_env
gen_kube_env
gen_latex_env
gen_llvm_env
gen_lisp_env
gen_oracle_env
gen_pandoc_env
gen_podman_env
gen_printer_env
gen_python_env
gen_racket_env
gen_rust_env
gen_secure_env
gen_tesseract_env
gen_unix_env
if on_darwin; then
  gen_macports_env
fi
gen_dot_exrc $HOME/.exrc

export PATH
. $HOME/.${SH}rc

unset PH
unset PLATFORM
unset SH
unset SH_ENV


END=$($date +%s)
$printf "\n... elpased %d seconds, successed.\n" $(( ${END}-${BEGIN} ))

# eof
